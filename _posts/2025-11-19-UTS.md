---
layout: draft
title: "Lazy Engineering: Analyzing the '7 Meters' GPS Logic in the UTS App"
date: 2025-11-19 11:15:00 +0530
categories: [AppDev, Engineering, UX]
tags: [UTS, GPS, Geofencing, BadCode, CRIS, IndianRailways]
image:
  path: /assets/img/headers/uts-gps-fail/header.webp
  lqip: data:image/jpeg;base64,...
---

## Background

##### Note: The discussion here is based on a [recent tweet by @spinesurgeon](https://x.com/spinesurgeon/status/1988978129701142835){:target="_blank"}.

A recent screenshot circulating on X (formerly Twitter) caught my eye, and it perfectly encapsulates a specific kind of "lazy engineering" that plagues government applications. The user was trying to book a ticket on the UTS (Unreserved Ticketing System) app and was greeted with this error:

<div align="center">
  <blockquote class="twitter-tweet"><p lang="en" dir="ltr">Your device GPS accuracy is 7 meters. Kindly stand 7 meter away from the railway station/track.</p>&mdash; Spine Surgeon (@spinesurgeon) <a href="https://twitter.com/spinesurgeon/status/1988978129701142835">November 19, 2025</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</div>

The error message reads:
> *"Your device GPS accuracy is 7 meters. Kindly stand 7 meter away from the railway station/track."*

This isn't just a bad user experience; it's a fascinating glimpse into the code running behind the scenes. It reveals exactly how the developers chose to handle the complex problem of geofencing.

## Deconstructing the Logic: Why Raw GPS Fails

As software engineers, we know that GPS is not a perfect coordinate system; it's a probability distribution. A GPS receiver doesn't say "You are at X, Y". It says, "I am 68% confident you are within Z meters of X, Y".

The error message reveals a naive implementation that treats this probabilistic data as deterministic. The developers likely implemented a simple distance check:

```java
// The likely culprit
float distanceToStation = userLocation.distanceTo(stationLocation);
float gpsAccuracy = userLocation.getAccuracy(); // e.g., 7.0 meters

// The "Lazy" Check
if (distanceToStation < gpsAccuracy) {
    throw new GeofenceException("Your device GPS accuracy is " + gpsAccuracy +
                                " meters. Kindly stand " + gpsAccuracy +
                                " meter away...");
}
```

This logic is fundamentally flawed because it ignores **Signal-to-Noise Ratio (SNR)**. In an "urban canyon" environment like a railway station—surrounded by high-voltage lines, metal structures, and concrete—multipath interference is rampant. Your GPS signal *will* drift. The "accuracy" value (often HDOP - Horizontal Dilution of Precision) is just an estimate of this uncertainty.

By coupling the user's permission to book a ticket directly to this raw, noisy `accuracy` value, the app is essentially asking the user to physically compensate for the noise in the L1/L5 GPS bands.

## The Engineering Fix: A Deep Dive

So, how do we fix this? We don't need users to walk across the road; we need **Signal Processing**. The goal is to convert a noisy stream of GPS coordinates into a stable, reliable location estimate.

### 1. The Kalman Filter: Smoothing the Noise

The gold standard for smoothing noisy sensor data is the **Kalman Filter**. It’s a recursive algorithm that estimates the state of a system (your location) from a series of incomplete and noisy measurements (raw GPS data).

In simple terms, a Kalman filter maintains two variables:
1.  **Estimated State**: Where we think we are.
2.  **Uncertainty (Covariance)**: How unsure we are about that location.

**The Algorithm in Action:**

1.  **Prediction Step**: Based on your last known position and velocity (if you're moving), the filter predicts where you should be at time `t+1`. It also increases its uncertainty because time has passed without a measurement.
2.  **Update Step**: A new GPS reading arrives with its own accuracy radius (noise).
3.  **Correction Step**: The filter fuses the *Prediction* and the *Measurement*.
    *   If the GPS accuracy is high (low noise), the filter trusts the measurement more.
    *   If the GPS accuracy is low (high noise, like 7m), the filter trusts its own prediction more.

**Pseudo-code Implementation:**

```python
class LocationFilter:
    def __init__(self):
        self.estimate = 0
        self.error_covariance = 1
        self.process_noise = 0.1 # Inherent system uncertainty

    def update(self, measurement, measurement_noise):
        # 1. Prediction (Simplified for static/slow moving user)
        prior_estimate = self.estimate
        prior_error = self.error_covariance + self.process_noise

        # 2. Kalman Gain calculation
        # K determines how much we trust the measurement vs. our estimate
        K = prior_error / (prior_error + measurement_noise)

        # 3. Correction
        self.estimate = prior_estimate + K * (measurement - prior_estimate)
        self.error_covariance = (1 - K) * prior_error

        return self.estimate
```

By running this loop, a "jumpy" GPS signal that oscillates between 5m and 20m error will smooth out into a stable trajectory. The app wouldn't see a sudden 7m jump; it would see a gradual drift that is statistically insignificant, preventing the error trigger.

### 2. Geofencing Hysteresis: The Schmitt Trigger Approach

Another failure here is the hard boundary. A binary "In/Out" check at the edge of a geofence causes "flickering"—where a user standing still appears to jump in and out of the zone due to GPS drift.

We need **Hysteresis**, similar to a Schmitt Trigger in electronics. We define two boundaries:
1.  **Outer Boundary (Safe Zone)**: e.g., 20 meters from track.
2.  **Inner Boundary (Danger Zone)**: e.g., 10 meters from track.

**State Machine Logic:**

*   **State: ALLOWED**: You are currently outside.
    *   To switch to **BLOCKED**, you must cross the *Inner Boundary* (get closer than 10m).
*   **State: BLOCKED**: You are currently inside.
    *   To switch to **ALLOWED**, you must cross the *Outer Boundary* (move further than 20m).

```java
enum State { ALLOWED, BLOCKED }
State currentState = State.BLOCKED;

void onLocationUpdate(Location loc) {
    float distance = loc.distanceTo(track);

    if (currentState == State.BLOCKED) {
        // Must move significantly away to unlock
        if (distance > 20.0) {
            currentState = State.ALLOWED;
        }
    } else {
        // Must move significantly close to lock
        if (distance < 10.0) {
            currentState = State.BLOCKED;
        }
    }
}
```

This "buffer zone" of 10 meters absorbs the GPS noise. Even if your GPS drifts by 7 meters, it won't trigger a state change because the threshold to change states is wider than the noise floor.

### 3. Android's Fused Location Provider

On Android, Google actually solves much of this with the `FusedLocationProviderClient`. It combines GPS, Wi-Fi, and Cell Tower triangulation to give a "fused" location.

The error message suggests the developers might be accessing the raw `LocationManager` GPS provider directly or misconfiguring the Fused provider. A proper implementation would request `PRIORITY_HIGH_ACCURACY` but would also check the `getSpeed()` and `getBearing()` to validate if a location change is physically possible (e.g., a human cannot accelerate to 50mph in 1 second).

## Conclusion

The "7 meters" error is not just a UX failure; it's a failure to apply basic control theory to a noisy real-world system. It exposes a lack of understanding of how GPS hardware actually works.

We have the tools—Kalman filters, Hysteresis state machines, and Fused Location providers—to handle this complexity. Dumping the raw hardware limitations onto the user in the form of an error message is the engineering equivalent of giving up.
